/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of Database.xs. Do not edit this file, edit Database.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Database.xs"
#define BLOCK Perl_BLOCK

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "notesdatabase.h"

#line 19 "Database.c"
XS(XS_Notes__Session_get_database)
{
    dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(s, ln_server = \"\", ln_db_path, ln_network_port = NULL)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Session *	s;
	char *	ln_db_path = (char *)SvPV(ST(2),PL_na);
	char *	ln_server;
	char *	ln_network_port;
#line 20 "Database.xs"
      d_LN_XSVARS;
      DBHANDLE      ln_db_handle;
      char          ln_db_path_canonical[ MAXPATH ];
      STATUS        ln_rc;
#line 37 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      s = (LN_Session *) ST(0);
   } else {
     warn( "Notes::Session::get_database() -- s is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;

	if (items < 2)
	    ln_server = "";
	else {
	    ln_server = (char *)SvPV(ST(1),PL_na);
	}

	if (items < 4)
	    ln_network_port = NULL;
	else {
	    ln_network_port = (char *)SvPV(ST(3),PL_na);
	}
#line 29 "Database.xs"
      ln_rc = OSPathNetConstruct(
                        ln_network_port,
                        ln_server,
                        ln_db_path,
                        ln_db_path_canonical
      					);
      if ( LN_IS_NOT_OK(s) )
      {
		  XSRETURN_NOT_OK;
	  }
      ln_rc = NSFDbOpen(
                    ln_db_path_canonical,
                    &ln_db_handle
      				);
      LN_SET_IVX(s, ln_rc);
      if ( LN_IS_NOT_OK(s) )
      {
		  XSRETURN_NOT_OK;
	  }

      LN_PUSH_NEW_OBJ( "Notes::Database", s );
      //printf("CREATED DBHANDLE: %ld\n", (long)ln_db_handle);
      LN_INIT_OBJ_STRUCT(NOTESDATABASE, ln_obj);
      LN_SET_DB_HANDLE(NOTESDATABASE, ln_obj, ln_db_handle);
      //printf("STORED DBHANDLE: %ld\n", (long)LN_DB_HANDLE(NOTESDATABASE,ln_obj));
      LN_SET_OK      ( ln_obj );
      XSRETURN       ( 1 );
#line 86 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Session_create_database)
{
    dXSARGS;
    dXSI32;
    if (items < 2 || items > 4)
       Perl_croak(aTHX_ "Usage: %s(s, ln_server = \"\", ln_db_path, bForceCreation = FALSE)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Session *	s;
	char *	ln_db_path = (char *)SvPV(ST(2),PL_na);
	char *	ln_server;
	BOOL	bForceCreation;
#line 65 "Database.xs"
      d_LN_XSVARS;
      DBHANDLE      ln_db_handle;
      char          ln_db_path_canonical[ MAXPATH ];
      STATUS        ln_rc;
#line 109 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      s = (LN_Session *) ST(0);
   } else {
     warn( "Notes::Session::create_database() -- s is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;

	if (items < 2)
	    ln_server = "";
	else {
	    ln_server = (char *)SvPV(ST(1),PL_na);
	}

	if (items < 4)
	    bForceCreation = FALSE;
	else {
	    bForceCreation = (int)SvIV(ST(3));
	}
#line 72 "Database.xs"
      if ( LN_IS_NOT_OK(s) )
	  {
		  DEBUG(("Notes::Session object was not OK at line %d", __LINE__));
	      XSRETURN_NOT_OK;
	  }
	  ln_rc = OSPathNetConstruct(
	                NULL,
	                ln_server,
	                ln_db_path,
	                ln_db_path_canonical
	  				);
	  if (ln_rc != NOERROR)
	  {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	  	  XSRETURN_NOT_OK;
  	  }
      if (ln_rc = NSFDbCreate (ln_db_path_canonical, DBCLASS_NOTEFILE, bForceCreation))
	  {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
		  LN_SET_IVX(s, ln_rc);
	      XSRETURN_NOT_OK;
	  }
	  if (ln_rc = NSFDbOpen(ln_db_path_canonical, &ln_db_handle))
	  {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
		  LN_SET_IVX(s, ln_rc);
	      XSRETURN_UNDEF;
	  }
	  LN_SET_IVX     ( s, ln_rc);
      LN_PUSH_NEW_OBJ( "Notes::Database", s );
      //printf("CREATED DBHANDLE: %ld\n", (long)ln_db_handle);
	  LN_INIT_OBJ_STRUCT(NOTESDATABASE, ln_obj);
	  LN_SET_DB_HANDLE(NOTESDATABASE, ln_obj, ln_db_handle);
      //printf("STORED DBHANDLE: %ld\n", (long)LN_DB_HANDLE(NOTESDATABASE,ln_obj));
      LN_SET_OK      ( ln_obj );
      XSRETURN       ( 1 );
#line 167 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_create_copy)
{
    dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       Perl_croak(aTHX_ "Usage: %s(db, ln_server = \"\", ln_db_path)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
	char *	ln_db_path = (char *)SvPV(ST(2),PL_na);
	char *	ln_server;
#line 119 "Database.xs"
      d_LN_XSVARS;
      DBHANDLE      ln_dst_handle;
      char          ln_src_db_path[ MAXPATH ];
      char 			ln_dst_can_server[ MAXUSERNAME ];
      char          ln_db_path_canonical[ MAXPATH ];
      STATUS        ln_rc;
#line 191 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::create_copy() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;

	if (items < 2)
	    ln_server = "";
	else {
	    ln_server = (char *)SvPV(ST(1),PL_na);
	}
#line 132 "Database.xs"
      if ( LN_IS_NOT_OK(db) )
	  {
		  DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
	      XSRETURN_NOT_OK;
	  }
	  ln_rc = DNCanonicalize( 0L, NULL, ln_server, (char FAR*)ln_dst_can_server,
     	    						MAXUSERNAME, NULL);
	  ln_rc = OSPathNetConstruct(
	                NULL,
	                ln_dst_can_server,
	                ln_db_path,
	                ln_db_path_canonical
	  				);
	  if (ln_rc != NOERROR)
	  {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	  	  XSRETURN_NOT_OK;
  	  }

	  ln_rc = NSFDbPathGet( LN_DB_HANDLE(NOTESDATABASE,db), NULL, ln_src_db_path );
	  if (ln_rc != NOERROR)
	  {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	  	  XSRETURN_NOT_OK;
  	  }

	  LN_SET_IVX(db, ln_rc);
	  if ( LN_IS_OK(db) )
      {
	  	  switch( ix )
	      {
              case   0: ln_rc = NSFDbCreateAndCopy(ln_src_db_path, ln_db_path_canonical, NOTE_CLASS_ALL, 0, 0, &ln_dst_handle);
                        break;
              case   1: ln_rc = NSFDbCreateAndCopy(ln_src_db_path, ln_db_path_canonical, NOTE_CLASS_ALLNONDATA, 0, 0, &ln_dst_handle);
	                    break;
	          case   2: ln_rc = NSFDbCreateAndCopy(ln_src_db_path, ln_db_path_canonical, NOTE_CLASS_ALL, 0, DBCOPY_REPLICA, &ln_dst_handle);
	                    break;
	          default:  XSRETURN_NOT_OK;
	                    break;
	      }
      }
      else
      {
	      XSRETURN_NOT_OK;
	  }
      LN_SET_IVX( db, ln_rc);
      if ( LN_IS_NOT_OK(db) )
	  {
		  DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
	      XSRETURN_NOT_OK;
	  }

      LN_PUSH_NEW_OBJ( "Notes::Database", db );
      //printf("CREATED DBHANDLE: %ld\n", (long)ln_dst_handle);
	  LN_INIT_OBJ_STRUCT(NOTESDATABASE, ln_obj);
	  LN_SET_DB_HANDLE(NOTESDATABASE, ln_obj, ln_dst_handle);
      //printf("STORED DBHANDLE: %ld\n", (long)LN_DB_HANDLE(NOTESDATABASE,ln_obj));
      LN_SET_OK      ( ln_obj );
      XSRETURN       ( 1 );
#line 266 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Notes::Database::DESTROY(db)");
    SP -= items;
    {
	LN_Database *	db;
#line 197 "Database.xs"
      STATUS          ln_rc;
#line 282 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::DESTROY() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 199 "Database.xs"
      //printf("CLOSING DBHANDLE: %ld\n", LN_DB_HANDLE(NOTESDATABASE, db));
      ln_rc = NSFDbClose( LN_DB_HANDLE(NOTESDATABASE, db) );
      LN_FREE_OBJ_STRUCT(NOTESDATABASE, db);
      //LN_SET_PARENT_IVX( db, ln_rc );
      XSRETURN( 0 );
#line 297 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_filename)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 210 "Database.xs"
      char            ln_canonical_path[ MAXPATH ];
      char            ln_expanded_path [ MAXPATH ];
      STATUS          ln_rc;
#line 316 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::filename() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 220 "Database.xs"
      ln_rc = NSFDbPathGet( LN_DB_HANDLE(NOTESDATABASE,db), ln_canonical_path, ln_expanded_path );
      LN_SET_IVX(db, ln_rc);
      if ( LN_IS_OK(db) )
      {
         switch( ix )
         {
            case   0: XPUSHs(sv_2mortal(newSVpv(ln_canonical_path, 0)));
                      XSRETURN( 1 );
                      break;
            case   1: XPUSHs(sv_2mortal(newSVpv(ln_expanded_path,  0)));
                      XSRETURN( 1 );
                      break;
            default:  XSRETURN_NOT_OK;
                      break;
         }
      }
      else
      {
		  DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		  XSRETURN_NOT_OK;
	  }
#line 347 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_title)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 247 "Database.xs"
      char            ln_buffer[NSF_INFO_SIZE];    /* database info buffer */
      char            ln_value[NSF_INFO_SIZE];     /* database title */
      STATUS          ln_rc;
#line 366 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::title() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 256 "Database.xs"
    /* Get the database buffer. */
    ln_rc = NSFDbInfoGet (LN_DB_HANDLE(NOTESDATABASE,db), ln_buffer);
    LN_SET_IVX(db, ln_rc);
	if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}

	switch( ix )
	{
	   	case  0:  NSFDbInfoParse (ln_buffer, INFOPARSE_TITLE, ln_value, NSF_INFO_SIZE - 1);
	              break;
	    case  1:  NSFDbInfoParse (ln_buffer, INFOPARSE_CATEGORIES, ln_value, NSF_INFO_SIZE - 1);
	              break;
	    case  2:  NSFDbInfoParse (ln_buffer, INFOPARSE_CLASS, ln_value, NSF_INFO_SIZE - 1);
	              break;
	    case  3:  NSFDbInfoParse (ln_buffer, INFOPARSE_DESIGN_CLASS, ln_value, NSF_INFO_SIZE - 1);
	              break;
	    default:  XSRETURN_NOT_OK;
	              break;
	}
	XPUSHs(sv_2mortal(newSVpv(ln_value, 0)));
	XSRETURN( 1 );
#line 400 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_is_public_address_book)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 285 "Database.xs"
      char            ln_buffer[NSF_INFO_SIZE];    /* database info buffer */
      char            ln_value[NSF_INFO_SIZE];     /* database title */
      STATUS          ln_rc;
#line 419 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::is_public_address_book() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 292 "Database.xs"
    /* Get the database buffer. */
    ln_rc = NSFDbInfoGet (LN_DB_HANDLE(NOTESDATABASE,db), ln_buffer);
    LN_SET_IVX(db, ln_rc);
	if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}
	NSFDbInfoParse (ln_buffer, INFOPARSE_DESIGN_CLASS, ln_value, NSF_INFO_SIZE - 1);

	switch( ix )
	{
	   	case  0:  if(strEQ(ln_value, PUBLIC_ADDRESSBOOK_TEMPLATE_NAME))
	   			  {
					  XSRETURN_YES;
			      }
	              break;
	    case  1:  if(strEQ(ln_value, PERSONAL_ADDRESSBOOK_TEMPLATE_NAME))
	              {
					  XSRETURN_YES;
			      }
	              break;
	    default:  XSRETURN_NOT_OK;
	              break;
	}
	XSRETURN_NO;
#line 455 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_compact)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 323 "Database.xs"
      char            ln_db_path[MAXPATH];
      DWORD           stats[2];      /* status return code */
      STATUS          ln_rc;
#line 474 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::compact() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 330 "Database.xs"
    if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}

	/* Get the database path. */
    if(ln_rc = NSFDbPathGet(LN_DB_HANDLE(NOTESDATABASE,db), NULL, ln_db_path))
	{
		DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
		XSRETURN_NOT_OK;
	}
	switch( ix )
	{
	   	case  0:  ln_rc = NSFDbCompact (ln_db_path, 0, &stats[0]);
	              break;
	    case  1:  ln_rc = NSFDbCompact (ln_db_path, DBCOMPACT_MAILBOX, &stats[0]);
	              break;
	    default:  XSRETURN_NOT_OK;
	              break;
	}
	LN_SET_IVX(db, ln_rc);
	if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}
	/* Return a perl array of the db size (in bytes)
	before and after compact() respectively. */
	XPUSHs(sv_2mortal(newSViv(stats[0])));
	XPUSHs(sv_2mortal(newSViv(stats[1])));
	XSRETURN( 2 );
#line 516 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_current_access_level)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 368 "Database.xs"
      WORD			  wAccessLevel;
      WORD			  wAccessFlag;
#line 534 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::current_access_level() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 374 "Database.xs"
    if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}

	NSFDbAccessGet(	LN_DB_HANDLE(NOTESDATABASE,db), &wAccessLevel, &wAccessFlag);

	/* Return a perl array of the ACCESS_LEVEL and
	ACCESS_FLAGS respectively. */
	XPUSHs(sv_2mortal(newSViv((IV)wAccessLevel)));
	XPUSHs(sv_2mortal(newSViv((IV)wAccessFlag)));
	XSRETURN( 2 );
#line 557 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_server)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 392 "Database.xs"
      STATUS          ln_rc;
      char		   	  ln_db_path[ MAXPATH ];
      char		   	  ln_server[ MAXUSERNAME ];
      char		   	  ln_server_canonical[ MAXUSERNAME ];
#line 577 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::server() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 400 "Database.xs"
    if ( LN_IS_NOT_OK(db) )
	{
		DEBUG(("Notes::Database object was not OK at line %d", __LINE__));
		XSRETURN_NOT_OK;
	}

	if(ln_rc = NSFDbPathGet(LN_DB_HANDLE(NOTESDATABASE,db), NULL, ln_db_path ))
	{
		DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	    XSRETURN_NOT_OK;
  	}
  	if(ln_rc = OSPathNetParse(ln_db_path, NULL, ln_server, NULL))
	{
		DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	    XSRETURN_NOT_OK;
  	}
  	if(ln_rc = DNCanonicalize( 0L, NULL, ln_server, (char FAR *)ln_server_canonical,
	     	    			   MAXUSERNAME, NULL))
	{
		DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	    XSRETURN_NOT_OK;
  	}

	XPUSHs(sv_2mortal(newSVpv(ln_server_canonical,0)));
	XSRETURN( 1 );
#line 612 "Database.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Database_is_encrypted)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(db)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	LN_Database *	db;
#line 431 "Database.xs"
      int             ln_is_encrypted;
      STATUS          ln_rc;
#line 630 "Database.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      db = (LN_Database *) ST(0);
   } else {
     warn( "Notes::Database::is_encrypted() -- db is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 437 "Database.xs"
      if(ln_rc = NSFDbIsLocallyEncrypted(LN_DB_HANDLE(NOTESDATABASE,db),&ln_is_encrypted))
      {
		  DEBUG(("Notes::Database object returning error %d at line %d", ln_rc, __LINE__));
	  	  XSRETURN_NOT_OK;
	  }
      if (ln_is_encrypted)
        XSRETURN_YES;
      else
        XSRETURN_NO;
#line 649 "Database.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Notes__Database)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        cv = newXS("Notes::Session::get_database", XS_Notes__Session_get_database, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Session::open_database", XS_Notes__Session_get_database, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Session::database", XS_Notes__Session_get_database, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Session::create_database", XS_Notes__Session_create_database, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Session::createdatabase", XS_Notes__Session_create_database, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::create_from_template", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::createreplica", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Notes::Database::createfromtemplate", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::create_copy", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::create_replica", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Notes::Database::createcopy", XS_Notes__Database_create_copy, file);
        XSANY.any_i32 = 0 ;
        newXS("Notes::Database::DESTROY", XS_Notes__Database_DESTROY, file);
        cv = newXS("Notes::Database::expanded_path", XS_Notes__Database_filename, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::filename", XS_Notes__Database_filename, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::filepath", XS_Notes__Database_filename, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::canonical_path", XS_Notes__Database_filename, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::path", XS_Notes__Database_filename, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::inherited_template", XS_Notes__Database_title, file);
        XSANY.any_i32 = 3 ;
        cv = newXS("Notes::Database::template", XS_Notes__Database_title, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("Notes::Database::categories", XS_Notes__Database_title, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::title", XS_Notes__Database_title, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::is_personal_address_book", XS_Notes__Database_is_public_address_book, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::is_public_address_book", XS_Notes__Database_is_public_address_book, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::compactmailbox", XS_Notes__Database_compact, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::compact_mailbox", XS_Notes__Database_compact, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("Notes::Database::compact", XS_Notes__Database_compact, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::current_access_level", XS_Notes__Database_current_access_level, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::currentaccesslevel", XS_Notes__Database_current_access_level, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::currentaccess", XS_Notes__Database_current_access_level, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::server", XS_Notes__Database_server, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::servername", XS_Notes__Database_server, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::server_name", XS_Notes__Database_server, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::isencrypted", XS_Notes__Database_is_encrypted, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::is_locally_encrypted", XS_Notes__Database_is_encrypted, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("Notes::Database::is_encrypted", XS_Notes__Database_is_encrypted, file);
        XSANY.any_i32 = 0 ;
    }
    XSRETURN_YES;
}

