/*
 * This file was generated automatically by xsubpp version 1.9508 from the 
 * contents of Object.xs. Do not edit this file, edit Object.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "Object.xs"
#define BLOCK Perl_BLOCK

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include "notesobject.h"

#line 19 "Object.c"
XS(XS_Notes__Object_is_ok)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Notes::Object::is_ok(o)");
    SP -= items;
    {
	LN_Object *	o;
#line 18 "Object.xs"
      d_LN_XSVARS;
#line 30 "Object.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      o = (LN_Object *) ST(0);
   } else {
     warn( "Notes::Object::is_ok() -- o is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 20 "Object.xs"
      if ( LN_IS_OK(o) )
      {
		  XSRETURN_OK;
	  }
	  else
	  {
		  XSRETURN_NOT_OK;
	  }
#line 48 "Object.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Object_is_not_ok)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Notes::Object::is_not_ok(o)");
    SP -= items;
    {
	LN_Object *	o;
#line 35 "Object.xs"
      d_LN_XSVARS;
#line 64 "Object.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      o = (LN_Object *) ST(0);
   } else {
     warn( "Notes::Object::is_not_ok() -- o is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 37 "Object.xs"
      if ( LN_IS_NOT_OK(o) )
      {
		  XSRETURN_OK;
	  }
	  else
	  {
		  XSRETURN_NOT_OK;
	  }
#line 82 "Object.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Object_status)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Notes::Object::status(o)");
    SP -= items;
    {
	LN_Object *	o;
#line 52 "Object.xs"
      d_LN_XSVARS;
#line 98 "Object.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      o = (LN_Object *) ST(0);
   } else {
     warn( "Notes::Object::status() -- o is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 54 "Object.xs"
      XSRETURN_IV( (IV) LN_IVX( o ) );
#line 109 "Object.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Object_set_status)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: Notes::Object::set_status(o, ln_stat_value)");
    SP -= items;
    {
	LN_Object *	o;
	int	ln_stat_value = (int)SvIV(ST(1));
#line 63 "Object.xs"
      d_LN_XSVARS;
#line 126 "Object.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      o = (LN_Object *) ST(0);
   } else {
     warn( "Notes::Object::set_status() -- o is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 65 "Object.xs"
      LN_SET_IVX( o, ln_stat_value );
      XSRETURN( 0 );
#line 138 "Object.c"
	PUTBACK;
	return;
    }
}

XS(XS_Notes__Object_status_text)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: Notes::Object::status_text(o)");
    SP -= items;
    {
	LN_Object *	o;
#line 74 "Object.xs"
      d_LN_XSVARS;
      char * ln_stat_text_lmbcs;
      char * ln_stat_text_native;
      WORD   ln_stat_text_length;
#line 157 "Object.c"

   /* NOTE: ALL O_LN_OBJECT C-types MUST be typedef'ed to SV  */
   if ( sv_isobject( ST(0) ) && ( SvTYPE( SvRV( ST(0) ) ) == SVt_PVMG) ) {
      o = (LN_Object *) ST(0);
   } else {
     warn( "Notes::Object::status_text() -- o is not a blessed SV reference" );
     XSRETURN_UNDEF;
   }   ;
#line 79 "Object.xs"
      /* Dynamically allocate our two status text buffers */
      Newz(1,ln_stat_text_lmbcs, LN_STAT_TEXT_LMBCS_LENGTH, char);
      if(ln_stat_text_lmbcs == (char *) NULL)
      {
		  XSRETURN_NOT_OK;
	  }

      /* Fetch Notes' status string in LMBCS, i.e.
       * MIXED Multi-Byte charstring format.
       */
      ln_stat_text_length = OSLoadString(
                               NULLHANDLE,
                               ERR( LN_IVX( o ) ),
                               ln_stat_text_lmbcs,
                               LN_STAT_TEXT_LMBCS_LENGTH
                            );
      if(ln_stat_text_length <= 0)
      {
         Safefree(ln_stat_text_lmbcs);
         XSRETURN_NOT_OK;
      }

      Newz(1, ln_stat_text_native, LN_STAT_TEXT_NATIVE_LENGTH, char);
      if(ln_stat_text_native == (char *) NULL)
      {
		  XSRETURN_NOT_OK;
	  }

      /* Translate from LMBCS to native, i.e. (single or double byte)
       * charstring to Native formatted text.
       */
      ln_stat_text_length = OSTranslate(
                               OS_TRANSLATE_LMBCS_TO_NATIVE,
                               ln_stat_text_lmbcs,
                               ln_stat_text_length,
                               ln_stat_text_native,
                               LN_STAT_TEXT_NATIVE_LENGTH
                            );
      if (ln_stat_text_length <= 0)
      {
         Safefree(ln_stat_text_lmbcs);
         Safefree(ln_stat_text_native);
         XSRETURN_NOT_OK;
      }

      XSRETURN_PV(ln_stat_text_native);
#line 213 "Object.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Notes__Object)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("Notes::Object::is_ok", XS_Notes__Object_is_ok, file);
        newXS("Notes::Object::is_not_ok", XS_Notes__Object_is_not_ok, file);
        newXS("Notes::Object::status", XS_Notes__Object_status, file);
        newXS("Notes::Object::set_status", XS_Notes__Object_set_status, file);
        newXS("Notes::Object::status_text", XS_Notes__Object_status_text, file);
    XSRETURN_YES;
}

